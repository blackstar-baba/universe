## 描述
### 即时编译器（JIT，Just In Time）
Java虚拟机最初都是通过解释器，将字节码解释为机器指令执行，当虚拟机发现某些代码运行的特别频繁（热点代码），为了提高这些代码的运行效率，就会将其转换并优化为机器指令码，运行时完成这个任务的后端编译器就是即时编译器。

HotSpot虚拟机中有3（JDK10之前只有2种）种即时编译器
C1 （Client Compiler）编译优化较少，但是编译所消耗资源也较少
C2 （Server Compiler）编译优化多，但是编译所消耗资源也多
Graal 为取代C2而生

通常解释器与C1或C2其中一个搭配工作，这种方式叫混合模式(Mixed Mode),为了达到响应时间与运行效率的平衡，出现了分层编译技术（Triered Compilation，JDK7 服务端模拟虚拟机默认开启），根据编译器编译、优化的规模以及耗时，分为不同层次，选择解释器或C1、C2中的一个进行执行，层次可以不同情况进行向上转化


### 提前编译器（AOT，Ahead Of Time）
使用普通JVM的Java程序启动慢，内存占用空间大,通常需要经历以下阶段：

![java_app_lifecycle](../../_images/java_app_lifecycle.png)

- vm init 虚拟机初始化
- app init 应用程序初始化
- app active(warmup) 应用程序预热
- app active(steady) 应用程序稳定运行
- shutdown 关闭

纵坐标代表 CPU 利用率，各个颜色的区域代表该行为的 CPU 使用率，红色区域的 VM 表示 JVM、青色的 CL 代表类加载（Class Loading），白色的是实时编译（Just In Time，JIT），黄色的代表垃圾回收（GC），浅绿色代表解释执行应用程序，绿色代表执行经过 JIT 编译的应用代码。

使用普通JVM的Java程序不适应云时代的需求，因此产生了提前编译器，提前将代码编译成为机器指令码。

### 编译器优化技术

#### 方法内联
最重要的经典优化技术，消除方法调用的成本（建立栈帧等），为其他优化提供依据。
在面向对象语言中需要考虑较多，比如方法的多版本，抽象方法、虚方法等等。

#### 逃逸分析
最前沿的经典优化技术之一，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。

逃逸分析的基本原理是：分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。

使用了逃逸分析后可用到的优化手段：
- 栈上分配：在栈上分配对象，随栈帧的销毁而销毁
- 标量替换：如果把一个Java对象拆散，根据程序访问的情况，将其用到的成员变量 恢复为原始类型来访问，这个过程就称为标量替换
- 同步消除：线程同步本身是一个相对耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那么这个变量的读写肯定就不会有竞争， 对这个变量实施的同步措施也就可以安全地消除掉


#### 公共子表达式消除
代码无关的经典经典优化技术之一，如果一个表达式E之前已经被计算过了，并且从先前的计算到现在，E中所有变量的值都没有发生变化，那么E的这次出现就称为公共子表达式。对于这种表达式，没有必要花时间再对它重新进行计算，只需要直接用前面计算过的表达式结果代替E。

#### 数组边界检查消除
代码相关的经典经典优化技术之一，Java中使用数组下标访问数组时，会隐含带上
`下标>=0&下标<数组长度`的条件，不满足则会抛出下标越界异常，对虚拟机执行效率不够友好

为了安全，数组边界检查肯定是要做的，但数组边界检查是不是必须在运行期间一次 不漏地进行则是可以“商量”的事情。例如下面这个简单的情况：数组下标是一个常量，如foo[3]，只要 在编译期根据数据流分析来确定foo.length的值，并判断下标“3”没有越界，执行的时候就无须判断了。

## 链接
-  《深入理解Java虚拟机》 - 11.2即时编译器
